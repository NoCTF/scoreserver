package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"unicode"

	strlib "github.com/nasa9084/go-strlib"
)

func (p *processor) Do() error {
	ctx := context{
		Dir: p.Dir,
	}
	if err := parseDir(&ctx, filepath.Join(ctx.Dir, "db")); err != nil {
		return err
	}
	if err := generateDBFile(&ctx); err != nil {
		return err
	}
	return nil
}

func parseDir(ctx *context, dir string) error {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, skipGen, parser.ParseComments)
	if err != nil {
		return err
	}
	if len(pkgs) == 0 {
		return errors.New("")
	}

	for _, pkg := range pkgs {
		if strings.HasSuffix(pkg.Name, "_test") {
			continue
		}
		ctx.PkgName = pkg.Name
		if err := process(ctx, pkg, ctx.modelInspector); err != nil {
			return err
		}
		return nil
	}
	return errors.New("")
}

func skipGen(fi os.FileInfo) bool {
	if strings.HasSuffix(fi.Name(), "_gen.go") {
		return false
	}
	return true
}

func (ctx *context) modelInspector(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok {
		return true
	}
	if decl.Tok != token.TYPE {
		return true
	}

	for _, spec := range decl.Specs {
		t, ok := spec.(*ast.TypeSpec)
		if !ok {
			continue
		}
		s, ok := t.Type.(*ast.StructType)
		if !ok {
			continue
		}
		commentGroup := decl.Doc
		if commentGroup == nil {
			continue
		}
		isModel := false
		for _, comment := range commentGroup.List {
			if strings.HasPrefix(strings.TrimSpace(strings.TrimPrefix(comment.Text, "//")), "db") {
				isModel = true
				break
			}
		}
		if !isModel {
			continue
		}
		d := db{
			Fields:  make([]field, 0, len(s.Fields.List)),
			Name:    t.Name.Name,
			PkgName: ctx.PkgName,
		}
		for _, f := range s.Fields.List {
			if len(f.Names) == 0 {
				continue
			}

			if unicode.IsLower(rune(f.Names[0].Name[0])) {
				continue
			}

			var jsonName string
			var v string
			if f.Tag != nil {
				v = f.Tag.Value
				v = strings.Trim(v, "`")
			}
			ft := reflect.StructTag(v)
			tag := ft.Get("json")
			if tag == "-" {
				continue
			}
			if tag == "" || tag[0] == ',' {
				jsonName = f.Names[0].Name
			} else {
				jsonName = strings.SplitN(tag, ",", 2)[0]
			}
			typ, err := getTypeName(f.Type)
			if err != nil {
				return true
			}
			isNullable := false
			if typ == "sql.NullString" {
				isNullable = true
				typ = "string"
			}

			fld := field{
				Name:       f.Names[0].Name,
				JSONName:   jsonName,
				Tag:        ft,
				Type:       typ,
				IsNullable: isNullable,
			}

			d.Fields = append(d.Fields, fld)
		}
		ctx.DBs = append(ctx.DBs, d)
	}

	return true
}

func getTypeName(ref ast.Expr) (string, error) {
	var typ string
	var err error
	switch ref.(type) {
	case *ast.Ident:
		return ref.(*ast.Ident).Name, nil
	case *ast.SelectorExpr:
		se := ref.(*ast.SelectorExpr)
		return se.X.(*ast.Ident).Name + "." + se.Sel.Name, nil
	case *ast.StarExpr:
		typ, err = getTypeName(ref.(*ast.StarExpr).X)
		if err != nil {
			return "", err
		}
		return "*" + typ, nil
	case *ast.ArrayType:
		typ = "[]" + ref.(*ast.ArrayType).Elt.(*ast.Ident).Name
	case *ast.MapType:
		mt := ref.(*ast.MapType)
		return "map[" + mt.Key.(*ast.Ident).Name + "]" + mt.Value.(*ast.Ident).Name, nil
	default:
		fmt.Printf("%#v\n", ref)
		return "", errors.New("field type not supported")
	}
	return "", errors.New("")
}

func process(ctx *context, pkg *ast.Package, inspector func(ast.Node) bool) error {
	for _, file := range pkg.Files {
		ast.Inspect(file, inspector)
	}
	return nil
}

func generateDBFile(ctx *context) error {
	for _, d := range ctx.DBs {
		buf := bytes.Buffer{}
		buf.WriteString("// Auto generated by gendb. DO NOT EDIT.\n")
		fmt.Fprintf(&buf, "package %s\n", ctx.PkgName)

		buf.WriteString("import (\n")
		buf.WriteString("\"errors\"\n")
		buf.WriteString("\"fmt\"\n")
		buf.WriteString("\"time\"\n")
		buf.WriteString(")\n")

		buf.WriteString("const (\n")
		fmt.Fprintf(&buf, "%sSelectCols = \"", d.Name)
		for i, f := range d.Fields {
			fmt.Fprintf(&buf, "%s", strlib.SnakeCase(f.Name))
			if i != len(d.Fields) -1 {
				buf.WriteString(", ")
			}
		}
		buf.WriteString("\"\n")
		fmt.Fprintf(&buf, "%sTable = \"%ss\"\n", d.Name, strings.ToLower(d.Name))
		buf.WriteString(")\n")

		buf.WriteString("var (\n")
		fmt.Fprintf(&buf, "ErrNotCreated%s = errors.New(`given %s is not created on database`)\n", d.Name, strings.ToLower(d.Name))
		buf.WriteString(")\n")

		fmt.Fprintf(&buf, "func (%s *%s) Scan(scanner Scanner) error {\n", strings.ToLower(d.Name), d.Name)
		buf.WriteString("return scanner.Scan(\n")
		for _, f := range d.Fields {
			fmt.Fprintf(&buf, "&%s.%s,\n", strings.ToLower(d.Name), f.Name)
		}
		buf.WriteString(")\n")
		buf.WriteString("}\n")

		fmt.Fprintf(&buf, "func (%s *%s) LoadByID(tx *Tx, id string) error {\n", strings.ToLower(d.Name), d.Name)
		fmt.Fprintf(&buf, "sql := fmt.Sprintf(`SELECT %%s FROM %%s WHERE %s = ?`, %sSelectCols, %sTable)\n", strings.ToLower(d.Fields[0].Name), d.Name, d.Name)
		buf.WriteString("stmt, err := db.Prepare(sql)\n")
		buf.WriteString("if err != nil {\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		buf.WriteString("row := tx.Stmt(stmt).QueryRow(id)\n")
		fmt.Fprintf(&buf, "if err := %s.Scan(row); err != nil {\n", strings.ToLower(d.Name))
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		buf.WriteString("return nil\n")
		buf.WriteString("}\n")

		fmt.Fprintf(&buf, "func (%s *%s) Create(tx *Tx) error {\n", strings.ToLower(d.Name), d.Name)
		fmt.Fprintf(&buf, "%s.CreatedOn = time.Now()\n", strings.ToLower(d.Name))
		buf.WriteString("stmt := fmt.Sprintf(`INSERT INTO %s (")
		for i, f := range d.Fields {
			fmt.Fprintf(&buf, "%s", strlib.SnakeCase(f.Name))
			if i != len(d.Fields) -1 {
				buf.WriteString(", ")
			}
		}
		fmt.Fprintf(&buf, ") VALUES (?, ?, ?, ?, ?, ?)`, %sTable)\n", d.Name)
		buf.WriteString("result, err := tx.Exec(stmt, ")
		for i, f := range d.Fields {
			fmt.Fprintf(&buf, "%s.%s", strings.ToLower(d.Name), f.Name)
			if i != len(d.Fields) -1 {
				buf.WriteString(", ")
			}
		}
		buf.WriteString(")\n")
		buf.WriteString("if err != nil {\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		buf.WriteString("lid, err := result.LastInsertId()\n")
		buf.WriteString("if err != nil {\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		fmt.Fprintf(&buf, "%s.%s = int(lid)\n", strings.ToLower(d.Name), d.Fields[0].Name)
		buf.WriteString("return nil\n")
		buf.WriteString("}\n")
		buf.WriteString("\n")

		fmt.Fprintf(&buf, "func (%s *%s) Update(tx *Tx) error {\n", strings.ToLower(d.Name), d.Name)
		fmt.Fprintf(&buf, "if %s.%s == 0 {\n", strings.ToLower(d.Name), d.Fields[0].Name)
		fmt.Fprintf(&buf, "return ErrNotCreated%s\n", d.Name)
		buf.WriteString("}\n")
		buf.WriteString("sql := fmt.Sprintf(`UPDATE %s SET ")
		for i, f := range d.Fields {
			fmt.Fprintf(&buf, "%s = ?", strlib.SnakeCase(f.Name))
			if i != len(d.Fields) - 1 {
				buf.WriteString(", ")
			}
		}
		fmt.Fprintf(&buf, "`, %sTable)\n", d.Name)
		buf.WriteString("stmt, err := db.Prepare(sql)\n")
		buf.WriteString("if err != nil {\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		buf.WriteString("_, err = tx.Stmt(stmt).Exec(")
		for i, f := range d.Fields {
			fmt.Fprintf(&buf, "%s.%s", strings.ToLower(d.Name), f.Name)
			if i != len(d.Fields) -1 {
				buf.WriteString(", ")
			}
		}
		buf.WriteString(")\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		buf.WriteString("\n")

		fmt.Fprintf(&buf, "func (%s *%s) Delete(tx *Tx) error {\n", strings.ToLower(d.Name), d.Name)
		fmt.Fprintf(&buf, "if %s.%s == 0 {\n", strings.ToLower(d.Name), d.Fields[0].Name)
		fmt.Fprintf(&buf, "return ErrNotCreated%s\n", d.Name)
		buf.WriteString("}\n")
		fmt.Fprintf(&buf, "sql := fmt.Sprintf(`DELETE FROM %%s WHERE %s = ?`, %sTable)\n", strlib.SnakeCase(d.Fields[0].Name), d.Name)
		buf.WriteString("stmt, err := db.Prepare(sql)\n")
		buf.WriteString("if err != nil {\n")
		buf.WriteString("return err\n")
		buf.WriteString("}\n")
		fmt.Fprintf(&buf, "_, err = tx.Stmt(stmt).Exec(%s.%s)\n", strings.ToLower(d.Name), d.Fields[0].Name)
		buf.WriteString("return err\n")
		buf.WriteString("}\n")

		fsrc, err := format.Source(buf.Bytes())
		if err != nil {
			return err
		}

		filename := filepath.Join(ctx.Dir, "db", strlib.SnakeCase(d.Name)+"_gen.go")
		fi, err := os.Create(filename)
		if err != nil {
			return err
		}
		defer fi.Close()

		if _, err := fi.Write(fsrc); err != nil {
			return err
		}
	}
	return nil
}
